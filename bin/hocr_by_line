#!/usr/bin/perl

# hocr_to_pdf - combine HOCR HTML file as generated by tesseract 3.0.1 with
# the overlaid image into a searchable PDF

use strict;
use warnings;
use Getopt::Long;
use Image::Size;
use PDF::API2;
use XML::Twig;
use autodie;

my $do_ocr = 0;
my $f_out   = '';
my $res     = 300;
my $debug   = 0;
my $target_res = 150;
my $min_xconf = 75;
my $keywords = '';
my @files = ();

($do_ocr, $res, $target_res, $f_out, $keywords, @files) = @ARGV;

my ($w_img, $h_img);
my @lines;
my @wb;
my @lb;

my $px = $target_res / 72;

my ($s,$m,$h,$d,$mo,$y) = localtime(time);
$mo += 1;
$y += 1900;
my $fulldatestring = sprintf 'D:%04d%02d%02d%02d%02d%02d', $y, $mo, $d, $h, $m, $s;

my $sf = $target_res / $res;

my $pdf = PDF::API2->new;
$pdf->info(
    'Author' => 'J Volkening',
    'CreationDate' => $fulldatestring,
    'ModDate' => $fulldatestring,
    'Creator' => 'scan.pl',
    'Keywords' => $keywords,
);
for my $file (@files) {

    # get image size in points
    ($w_img, $h_img) =  imgsize($file);
    ($w_img, $h_img) = map {$_ / $px} ($w_img, $h_img);

    my $page = $pdf->page;

    # add background image
    $page->mediabox( $w_img, $h_img );
    my $overlay = $page->gfx;
    my $pic = $pdf->image_png($file);
    $overlay->image( $pic, 0, 0, $w_img, $h_img );

    # intialize font and font info
    my $f = $pdf->corefont( 'helvetica' );

    if ($do_ocr) {

        my $f_hocr = $file;
        $f_hocr =~ s/png/hocr/;

        # populate @words with word string and coordinates
        @wb = ();
        parse_hocr( $f_hocr );
        for my $word (@wb) {

            # each $word contains (in points):
            # 0 : lower-left x 
            # 1 : lower-left y
            # 2 : bbox width
            # 3 : text

            my $text = $word->[3];

            my $t = $page->text;
            $t->fillcolor('red') if ($debug);
            $t->render(3) if (! $debug) ; # make text invisible
            $t->font( $f, 10 ); # set size arbitrarily, scale later
            my $x = $word->[0];
            my $y = $word->[1]; 
            $t->translate($x,$y);
            my $w = $t->advancewidth($text);
            my $scale_factor = $word->[2] / $w;
            $t->font( $f, 10*$scale_factor );
            $t->text($text);

        }
    }
    
}

$pdf->saveas("$f_out");
exit;

sub parse_hocr {

    my ($filename) = @_;
    my $doc = XML::Twig->new(
        twig_roots => { 'span' => \&_parse_span },
    );
    $doc->parsefile($filename,ProtocolEncoding => 'UTF-8');

}

sub _parse_span {

    my ($twig, $element) = @_;
    return if ($element->att('class') ne 'ocr_line');
    my @spans = $element->children('span');
    for (@spans) {
        next if ($_->att('class') ne 'ocrx_word');
        my $word = $_->first_child_text;
        next if ($word !~ /\S/);
        my ($bbox,$conf) = split /;\s*/, $_->att('title');
        my ($discard, @coords) = split /\s/, $bbox;
        my ($discard2, $xconf) = split /\s/, $conf;
        next if ($xconf < $min_xconf);
        @coords = map {$_ * $sf} @coords;
        @coords = map {$_ / $px} @coords; # convert to pixel space

        my $y = $h_img - $coords[3];
        $y += ($coords[3] - $coords[1]) * .3 if ($word =~ /[\(\)ygpq,;]/);
        push @wb, [$coords[0],$y,$coords[2] - $coords[0],$word];
        die "missing word" if (! defined $word);
    }
    return;

}
